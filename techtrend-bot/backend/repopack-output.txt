================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-25T18:37:09.865Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
package.json
src/config/database.js
src/config/redis.js
src/cron/updateTrends.js
src/models/Chat.js
src/models/Trend.js
src/models/User.js
src/routes/auth.js
src/routes/chat.js
src/routes/trends.js
src/routes/user.js
src/server.js
src/services/bedrockService.js
src/services/trendAnalysisService.js
src/services/trendIngestionService.js
src/utils/authMiddleware.js

================================================================
Repository Files
================================================================

================
File: package.json
================
{
  "name": "techtrend-bot-backend",
  "version": "1.0.0",
  "description": "Backend for TechTrendBot",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "dependencies": {
    "@aws-sdk/client-bedrock-runtime": "^3.637.0",
    "axios": "^0.21.4",
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^10.0.0",
    "express": "^4.19.2",
    "jsonwebtoken": "^8.5.1",
    "mongoose": "^6.13.0",
    "natural": "^5.2.4",
    "node-cron": "^3.0.3",
    "redis": "^4.7.0"
  },
  "devDependencies": {
    "nodemon": "^2.0.12"
  }
}

================
File: src/config/database.js
================
// backend/src/config/database.js
const mongoose = require('mongoose');

const connectDB = async () => {
  try {
    await mongoose.connect(process.env.MONGODB_URI, {
      useNewUrlParser: true,
      useUnifiedTopology: true,
    });
    console.log('MongoDB connected');
  } catch (error) {
    console.error('MongoDB connection error:', error);
    process.exit(1);
  }
};

module.exports = { connectDB };

================
File: src/config/redis.js
================
// backend/src/config/redis.js
const redis = require('redis');

let redisClient;

const connectRedis = async () => {
  redisClient = redis.createClient({
    url: process.env.REDIS_URL
  });

  redisClient.on('error', (error) => console.error(`Redis Error : ${error}`));

  await redisClient.connect();
  console.log('Redis connected');
};

const getRedisClient = () => {
  if (!redisClient) {
    throw new Error('Redis client not initialized');
  }
  return redisClient;
};

module.exports = { connectRedis, getRedisClient };

================
File: src/cron/updateTrends.js
================
const cron = require('node-cron');
const { ingestRSSFeed, ingestGitHubTrending } = require('../services/trendIngestionService');

const startCronJobs = () => {
  cron.schedule('0 */6 * * *', async () => {
    console.log('Updating tech trends...');
    await ingestRSSFeed('https://feeds.feedburner.com/TechCrunch/', 'General');
    await ingestRSSFeed('https://www.wired.com/feed/rss', 'General');
    await ingestRSSFeed('https://www.theverge.com/rss/index.xml', 'General');
    await ingestGitHubTrending();
    console.log('Tech trends updated.');
  });
};
module.exports = { startCronJobs };

================
File: src/models/Chat.js
================
// backend/src/models/Chat.js
const mongoose = require('mongoose');

const ChatSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  messages: [{
    role: { type: String, enum: ['user', 'assistant'], required: true },
    content: { type: String, required: true },
    timestamp: { type: Date, default: Date.now }
  }],
  title: String,
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Chat', ChatSchema);

================
File: src/models/Trend.js
================
// backend/src/models/Trend.js
const mongoose = require('mongoose');

const TrendSchema = new mongoose.Schema({
  title: { type: String, required: true },
  description: String,
  source: { type: String, required: true },
  url: { type: String, required: true },
  category: { type: String, required: true },
  relevanceScore: { type: Number, required: true },
  timestamp: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Trend', TrendSchema);

================
File: src/models/User.js
================
// backend/src/models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  email: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  favoriteChats: [{ type: mongoose.Schema.Types.ObjectId, ref: 'Chat' }],
  createdAt: { type: Date, default: Date.now }
});

UserSchema.pre('save', async function(next) {
  if (this.isModified('password')) {
    this.password = await bcrypt.hash(this.password, 8);
  }
  next();
});

module.exports = mongoose.model('User', UserSchema);

================
File: src/routes/auth.js
================
// backend/src/routes/auth.js
const express = require('express');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const router = express.Router();

router.post('/register', async (req, res) => {
  try {
    const { username, email, password } = req.body;
    let user = await User.findOne({ email });
    if (user) {
      return res.status(400).json({ error: 'User already exists' });
    }
    user = new User({ username, email, password });
    await user.save();
    const payload = { user: { id: user.id } };
    jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' }, (err, token) => {
      if (err) throw err;
      res.json({ token });
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Server error' });
  }
});

router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    let user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ error: 'Invalid credentials' });
    }
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ error: 'Invalid credentials' });
    }
    const payload = { user: { id: user.id } };
    jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: '1h' }, (err, token) => {
      if (err) throw err;
      res.json({ token });
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Server error' });
  }
});

module.exports = router;

================
File: src/routes/chat.js
================
// backend/src/routes/chat.js
const express = require('express');
const router = express.Router();
const authMiddleware = require('../utils/authMiddleware');
const { generateTrendResponse } = require('../services/bedrockService');
const Chat = require('../models/Chat');
const Trend = require('../models/Trend');
const User = require('../models/User');

router.post('/', authMiddleware, async (req, res) => {
  try {
    const { message } = req.body;
    const userId = req.user.id;

    const recentTrends = await Trend.find().sort({ timestamp: -1 }).limit(10);
    const aiResponse = await generateTrendResponse(message, recentTrends);

    let chat = await Chat.findOne({ user: userId }).sort({ createdAt: -1 });
    if (!chat) {
      chat = new Chat({ user: userId, messages: [] });
    }

    chat.messages.push({ role: 'user', content: message });
    chat.messages.push({ role: 'assistant', content: aiResponse });
    await chat.save();

    res.json({ message: aiResponse, chatId: chat._id });
  } catch (error) {
    console.error('Error in chat route:', error);
    res.status(500).json({ error: 'An error occurred' });
  }
});

router.post('/favorite', authMiddleware, async (req, res) => {
  try {
    const { chatId } = req.body;
    const userId = req.user.id;

    await User.findByIdAndUpdate(userId, { $addToSet: { favoriteChats: chatId } });
    res.json({ message: 'Chat added to favorites' });
  } catch (error) {
    console.error('Error adding chat to favorites:', error);
    res.status(500).json({ error: 'An error occurred' });
  }
});

router.get('/favorites', authMiddleware, async (req, res) => {
  try {
    const userId = req.user.id;
    const user = await User.findById(userId).populate('favoriteChats');
    res.json(user.favoriteChats);
  } catch (error) {
    console.error('Error fetching favorite chats:', error);
    res.status(500).json({ error: 'An error occurred' });
  }
});

module.exports = router;

================
File: src/routes/trends.js
================
const express = require('express');
const router = express.Router();
const Trend = require('../models/Trend');

router.get('/', async (req, res) => {
  try {
    const trends = await Trend.find().sort({ timestamp: -1 }).limit(20);
    res.json(trends);
  } catch (error) {
    console.error('Error fetching trends:', error);
    res.status(500).json({ error: 'An error occurred' });
  }
});

module.exports = router;

================
File: src/routes/user.js
================
// backend/src/routes/user.js
const express = require('express');
const router = express.Router();
const authMiddleware = require('../utils/authMiddleware');
const User = require('../models/User');

// Get user profile
router.get('/profile', authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    console.error('Error fetching user profile:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Update user profile
router.put('/profile', authMiddleware, async (req, res) => {
  const { username, email } = req.body;

  try {
    let user = await User.findById(req.user.id);
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    if (username) user.username = username;
    if (email) user.email = email;

    await user.save();

    res.json(user);
  } catch (error) {
    console.error('Error updating user profile:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

// Get user's favorite chats
router.get('/favorite-chats', authMiddleware, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).populate('favoriteChats');
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user.favoriteChats);
  } catch (error) {
    console.error('Error fetching favorite chats:', error);
    res.status(500).json({ error: 'Server error' });
  }
});

module.exports = router;

================
File: src/server.js
================
// backend/src/server.js
require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { connectDB } = require('./config/database');
const { connectRedis } = require('./config/redis');
const authRoutes = require('./routes/auth');
const chatRoutes = require('./routes/chat');
const trendsRoutes = require('./routes/trends');
const userRoutes = require('./routes/user');
const { startCronJobs } = require('./cron/updateTrends');

const app = express();

connectDB();
connectRedis();

app.use(cors());
app.use(express.json());

app.use('/api/auth', authRoutes);
app.use('/api/chat', chatRoutes);
app.use('/api/trends', trendsRoutes);
app.use('/api/user', userRoutes);

startCronJobs();

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));

================
File: src/services/bedrockService.js
================
// backend/src/services/bedrockService.js
const { BedrockRuntimeClient, InvokeModelCommand } = require("@aws-sdk/client-bedrock-runtime");
const { getRedisClient } = require('../config/redis');

const bedrockClient = new BedrockRuntimeClient({
  region: process.env.AWS_REGION,
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  },
});

const generateTrendResponse = async (message, recentTrends) => {
  const redisClient = getRedisClient();
  const cacheKey = `chat:${message}`;
  
  // Try to get the response from cache
  const cachedResponse = await redisClient.get(cacheKey);
  if (cachedResponse) {
    return JSON.parse(cachedResponse);
  }

  const prompt = `You are an AI assistant specialized in discussing the latest technology trends. 
                  Here are some recent tech trends: ${JSON.stringify(recentTrends)}
                  User's message: ${message}
                  Provide an informative response about current tech trends:`;

  const params = {
    modelId: "anthropic.claude-v2",
    contentType: "application/json",
    accept: "application/json",
    body: JSON.stringify({
      prompt: prompt,
      max_tokens_to_sample: 300,
      temperature: 0.7,
      top_p: 1,
      top_k: 250,
      stop_sequences: ["\n\nHuman:"],
    }),
  };

  try {
    const command = new InvokeModelCommand(params);
    const response = await bedrockClient.send(command);
    const responseBody = JSON.parse(new TextDecoder().decode(response.body));
    
    // Cache the response
    await redisClient.set(cacheKey, JSON.stringify(responseBody.completion), {
      EX: 3600 // Expire after 1 hour
    });
    
    return responseBody.completion;
  } catch (error) {
    console.error('Error calling Bedrock:', error);
    throw error;
  }
};

module.exports = { generateTrendResponse };

================
File: src/services/trendAnalysisService.js
================
// backend/src/services/trendAnalysisService.js
const natural = require('natural');
const Trend = require('../models/Trend');
const { getRedisClient } = require('../config/redis');

const tfidf = new natural.TfIdf();

const analyzeRelevanceScore = async (title, description) => {
  const redisClient = getRedisClient();
  const cacheKey = `relevance:${title}`;

  // Try to get the relevance score from cache
  const cachedScore = await redisClient.get(cacheKey);
  if (cachedScore) {
    return parseFloat(cachedScore);
  }

  const allTrends = await Trend.find({}, 'title description');
  
  allTrends.forEach(trend => {
    tfidf.addDocument(`${trend.title} ${trend.description}`);
  });

  const newDocument = `${title} ${description}`;
  tfidf.addDocument(newDocument);

  const scores = tfidf.tfidf(newDocument, tfidf.documents.length - 1);
  const relevanceScore = Math.min(...scores) * 100; // Normalize to 0-100 scale

  // Cache the relevance score
  await redisClient.set(cacheKey, relevanceScore.toString(), {
    EX: 3600 // Expire after 1 hour
  });

  return relevanceScore;
};

module.exports = { analyzeRelevanceScore };

================
File: src/services/trendIngestionService.js
================
// backend/src/services/trendIngestionService.js
const axios = require('axios');
const Trend = require('../models/Trend');
const { analyzeRelevanceScore } = require('./trendAnalysisService');
const { getRedisClient } = require('../config/redis');

const ingestRSSFeed = async (feedUrl, category) => {
  const redisClient = getRedisClient();
  try {
    const cacheKey = `rssfeed:${feedUrl}`;
    let items;

    // Try to get the feed from cache
    const cachedFeed = await redisClient.get(cacheKey);
    if (cachedFeed) {
      items = JSON.parse(cachedFeed);
    } else {
      const response = await axios.get(feedUrl);
      items = response.data.items || [];
      // Cache the feed
      await redisClient.set(cacheKey, JSON.stringify(items), {
        EX: 3600 // Expire after 1 hour
      });
    }

    for (const item of items) {
      const relevanceScore = await analyzeRelevanceScore(item.title, item.description);
      const trend = new Trend({
        title: item.title,
        description: item.description,
        source: feedUrl,
        url: item.link,
        category: category,
        relevanceScore: relevanceScore
      });
      await trend.save();
    }
  } catch (error) {
    console.error(`Error ingesting RSS feed ${feedUrl}:`, error);
  }
};

const ingestGitHubTrending = async () => {
  const redisClient = getRedisClient();
  try {
    const cacheKey = 'github:trending';
    let items;

    // Try to get the trending repos from cache
    const cachedRepos = await redisClient.get(cacheKey);
    if (cachedRepos) {
      items = JSON.parse(cachedRepos);
    } else {
      const response = await axios.get('https://api.github.com/search/repositories?q=created:>2023-01-01&sort=stars&order=desc');
      items = response.data.items || [];
      // Cache the trending repos
      await redisClient.set(cacheKey, JSON.stringify(items), {
        EX: 3600 // Expire after 1 hour
      });
    }

    for (const item of items) {
      const relevanceScore = await analyzeRelevanceScore(item.name, item.description);
      const trend = new Trend({
        title: item.name,
        description: item.description,
        source: 'GitHub Trending',
        url: item.html_url,
        category: 'OpenSource',
        relevanceScore: relevanceScore
      });
      await trend.save();
    }
  } catch (error) {
    console.error('Error ingesting GitHub trending:', error);
  }
};

module.exports = { ingestRSSFeed, ingestGitHubTrending };

================
File: src/utils/authMiddleware.js
================
// backend/src/utils/authMiddleware.js
const jwt = require('jsonwebtoken');

module.exports = (req, res, next) => {
  const token = req.header('Authorization')?.replace('Bearer ', '');

  if (!token) {
    return res.status(401).json({ error: 'No token, authorization denied' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded.user;
    next();
  } catch (err) {
    res.status(401).json({ error: 'Token is not valid' });
  }
};
